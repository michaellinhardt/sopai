# Fact Check: Ralph Live Editing Capabilities

## Claim

Ralph allows live editing of specifications and plan files while the loop is running, with changes picked up on the next iteration.

## Sources Found

1. **[GitHub - snarktank/ralph](https://github.com/snarktank/ralph)** - Original Ralph implementation documentation
2. **[GitHub - ghuntley/how-to-ralph-wiggum](https://github.com/ghuntley/how-to-ralph-wiggum)** - Geoffrey Huntley's original methodology documentation
3. **[GitHub - ClaytonFarr/ralph-playbook](https://github.com/ClaytonFarr/ralph-playbook)** - Comprehensive Ralph methodology guide
4. **[Getting Started With Ralph - AIHero](https://www.aihero.dev/getting-started-with-ralph)** - Tutorial documentation
5. **[Ralph Wiggum - Autonomous Loops - Paddo.dev](https://paddo.dev/blog/ralph-wiggum-autonomous-loops/)** - Blog post on autonomous loops

## Verdict

**VERIFIED**

## Analysis

### Supporting Evidence

The claim is verified based on Ralph's fundamental architecture and explicit documentation:

1. **File-Based State Management**: Ralph uses a disk-based coordination system where each iteration deterministically loads the same files (PROMPT.md, AGENTS.md, specs/*, IMPLEMENTATION_PLAN.md, prd.json) from disk. The documentation states: *"Each iteration deterministically loads the same files and reads the current state from disk."*

2. **Fresh Context Per Iteration**: Each loop iteration spawns a fresh agent instance with clean context. Memory persists via files and git history, not in-memory state. This means the agent has no "memory" of previous file contents - it always reads the current state from disk.

3. **Explicit Documentation of Mid-Loop Editing**: The snarktank/ralph documentation explicitly confirms: *"You can adjust while Ralph is running. Already implemented but wrong? Set passes back to false, add notes, rerun. Missing a feature? Add a new PRD item even mid-loop."*

4. **Add Context Feature**: Some implementations include explicit commands like `ralph --add-context` that allow users to *"Guide a struggling agent without stopping the loop"* by adding context that is automatically consumed after one iteration.

5. **Plan Regeneration Guidance**: The ralph-playbook recommends regenerating plans when: *"Ralph is going off track, Plan feels stale or doesn't match current state, You've made significant spec changes"* - implying that spec changes during execution are a normal workflow.

### Technical Basis

The capability works because:

- Ralph's bash loop simply restarts the agent repeatedly
- Each iteration reads all configuration and state files fresh from disk
- No sophisticated orchestration or caching prevents detection of file changes
- The IMPLEMENTATION_PLAN.md file *"persists on disk between iterations and acts as shared state between otherwise isolated loop executions"*

### Caveats

- Users should avoid modifying files that are actively being written by the current iteration to prevent race conditions
- Changes take effect on the **next** iteration, not the current one
- This is an architectural byproduct of the stateless design, not necessarily a deliberately designed "hot reload" feature

### Conclusion

The claim accurately describes Ralph's behavior. The file-based, fresh-context architecture inherently supports live editing of specifications and plan files, and this capability is explicitly documented as a feature in multiple Ralph implementations and guides.
